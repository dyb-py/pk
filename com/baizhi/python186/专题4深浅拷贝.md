# 深浅拷贝

* 概念

~~~markdown
引用：C++提出的一种新型的使用变量的方式
		变量存储的是数据本身
		指针：变量中存储的是数据的首地址
		引用：变量中存储的是对象的首地址
		Python会直接或间接的将所有数据转换成对象---一切皆对象
1. 浅拷贝：
		拷贝了外围对象的本身，内部的对象只是拷贝了引用
		外部看起来是多个对象，内部是共用同一个对象
2. 深拷贝：
		拷贝了外围对象同时也拷贝了内部的对象
~~~

* 浅拷贝的特点

~~~markdown
1. 优点
		节约资源
2. 缺点
		如果内部对象是可变类型，则会牵一发而动全局\
3. 赋值运算是一种特殊的浅拷贝
		l1=l2
~~~

~~~python
# l1=[1,2,3]
# l2=l1.copy()  # 拷贝： 内容一样，首地址不一样
# print(id(l1),id(l2))
# # 首地址不一样，无论内容是否一样，都一定不是同一个对象
# # 浅拷贝： 浅层靠上的数据发生了拷贝，靠下的数据没有发生拷贝
# print(l1,l2)
# print(id(l1[0]),id(l2[0])) # 内层共用数据
#
# l1[0]=99
# print(l1,l2)

l1=[[1,2,3],[4,5,6],[7,8,9]]
l2=l1.copy()
print(l1,l2)
print(id(l1),id(l2))
l1[0][0]=99
print(l1,l2)
# 内层对象如果是一个可变类型的对象，内层对象的内部元素改变，
# 不会影响内层对象的首地址，因此不会影响外层数据的共享（保持共享状态），
# 此时如果内部可变类型数据修改，则会影响所有的外部数据（牵一发而动全局）
# 如果内部对象是不可变类型数据，和以上说法无关
~~~

* 深拷贝

~~~markdown
1. 优势：
		数据备份
		容灾机制
2. 劣势：
		占用资源
~~~

~~~python
import copy

l1=[[1,2,3],[4,5,6],[7,8,9]]
l2=copy.deepcopy(l1)
print(l1)
print(l2)
print(id(l1))
print(id(l2))
print(id(l1[0]))
print(id(l2[0]))
l1[0][0]=99
print(l1)
print(l2)
~~~

---

* 补充：

~~~python
-5~256  整数Python已经创建好的，首地址固定的
常量池
~~~

---

